# ğŸš² LeetCode-Hot100

## 1. å“ˆå¸Œ

### Q1. ä¸¤æ•°ä¹‹å’Œ

#### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ target çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ åœ¨ç­”æ¡ˆé‡Œä¸èƒ½é‡å¤å‡ºç°ã€‚

ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚

ç¤ºä¾‹ 1ï¼š

> è¾“å…¥ï¼šnums = \[2,7,11,15], target = 9
>
> è¾“å‡ºï¼š\[0,1]
>
> è§£é‡Šï¼šå› ä¸º nums\[0] + nums\[1] == 9 ï¼Œè¿”å› \[0, 1] ã€‚

ç¤ºä¾‹ 2ï¼š

> è¾“å…¥ï¼šnums = \[3,2,4], target = 6
>
> è¾“å‡ºï¼š\[1,2]

ç¤ºä¾‹ 3ï¼š

> è¾“å…¥ï¼šnums = \[3,3], target = 6
>
> è¾“å‡ºï¼š\[0,1]

#### é¢˜è§£ï¼š

1. ä¸¤å±‚forå¾ªç¯è¿›è¡Œéå†ï¼Œå¤æ‚åº¦ä¸º $$O(N^2)$$

```go
func twoSum(nums []int, target int) []int {
	for i := 0; i < len(nums) - 1; i++ {
		for j := i + 1; j < len(nums); j++ {
			if nums[i] + nums[j] == target {
				return []int{i, j}
            		}           
        	}   
    	}
	return nil
}
```

2. ä½¿ç”¨å“ˆå¸Œè¡¨ï¼Œå¯»æ‰¾æ˜¯å¦å­˜åœ¨target - xï¼Œå¤æ‚åº¦ä¸º $$O(N)$$

```go
func twoSum(nums []int, target int) []int {
	hashTable := map[int]int{}
	for i, x := range nums {
		if p, ok := hashTable[target - x]; ok {
			return []int{p, i}
        }
		hashTable[x] = i
    }
	return nil
}
```

### Q49. å­—æ¯å¼‚ä½è¯åˆ†ç»„

#### é¢˜ç›®æè¿°

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œè¯·ä½ å°† å­—æ¯å¼‚ä½è¯ ç»„åˆåœ¨ä¸€èµ·ã€‚å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç»“æœåˆ—è¡¨ã€‚

å­—æ¯å¼‚ä½è¯ æ˜¯ç”±é‡æ–°æ’åˆ—æºå•è¯çš„æ‰€æœ‰å­—æ¯å¾—åˆ°çš„ä¸€ä¸ªæ–°å•è¯ã€‚

ç¤ºä¾‹ 1:

> è¾“å…¥: strs = \["eat", "tea", "tan", "ate", "nat", "bat"]
>
> è¾“å‡º: \[\["bat"],\["nat","tan"],\["ate","eat","tea"]]

ç¤ºä¾‹ 2:

> è¾“å…¥: strs = \[""]
>
> è¾“å‡º: \[\[""]]

ç¤ºä¾‹ 3:

> è¾“å…¥: strs = \["a"]
>
> è¾“å‡º: \[\["a"]]

#### é¢˜è§£

é¦–å…ˆå¯¹æ¯ä¸€ä¸ªå•è¯å†…éƒ¨å­—æ¯è¿›è¡Œæ’åºï¼Œç„¶åå°†ç›¸åŒçš„åˆ†ä¸ºä¸€ç»„ã€‚åˆ†ç»„çš„è¿‡ç¨‹æ˜¯æ€§èƒ½ç“¶é¢ˆï¼Œä¸ä¸¤æ•°ä¹‹å’Œä¸€æ ·ï¼Œå¦‚æœæš´åŠ›çš„è¯è¿˜æ˜¯ä¸¤å±‚forå¾ªç¯ï¼Œç„¶åæ—¶é—´å¤æ‚åº¦è¿˜æ˜¯$O(N^2)$ ï¼Œæ‰€ä»¥è¿˜æ˜¯ä½¿ç”¨å“ˆå¸Œè¡¨è¿›è¡Œå­˜å‚¨ã€‚

```go
func groupAnagrams(strs []string) [][]string {
	mp := map[string][]string{}
	for _, str := range strs {
		s := []byte(str)
		// å¯¹å•è¯å†…éƒ¨è¿›è¡ŒASIICç æ’åº
		sort.Slice(s, func(i, j int) bool { return s[i] < s[j] })
		//fmt.Println(s)
		sortedStr := string(s)
		mp[sortedStr] = append(mp[sortedStr], str)
	}
	ans := make([][]string, 0)
	for _, v := range mp {
		ans = append(ans, v)
	}
	return ans
}
```

### Q128. æœ€é•¿è¿ç»­åºåˆ—

#### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾å‡ºæ•°å­—è¿ç»­çš„æœ€é•¿åºåˆ—ï¼ˆä¸è¦æ±‚åºåˆ—å…ƒç´ åœ¨åŸæ•°ç»„ä¸­è¿ç»­ï¼‰çš„é•¿åº¦ã€‚

è¯·ä½ è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º O(n) çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚

ç¤ºä¾‹ 1ï¼š

> è¾“å…¥ï¼šnums = \[100,4,200,1,3,2]
>
> è¾“å‡ºï¼š4
>
> è§£é‡Šï¼šæœ€é•¿æ•°å­—è¿ç»­åºåˆ—æ˜¯ \[1, 2, 3, 4]ã€‚å®ƒçš„é•¿åº¦ä¸º 4ã€‚

ç¤ºä¾‹ 2ï¼š

> è¾“å…¥ï¼šnums = \[0,3,7,2,5,8,4,6,0,1]
>
> è¾“å‡ºï¼š9

#### é¢˜è§£

1. é¦–å…ˆåˆ¤æ–­æ˜¯ nums é•¿åº¦å¦å°äºç­‰äº1ï¼Œå¦‚æœå°äºç­‰äº1ï¼Œç›´æ¥è¿”å›å¯¹åº”é•¿åº¦å³å¯ï¼Œç„¶åè®¾ç½®èµ·å§‹é•¿åº¦ ans å’Œä¸´æ—¶é•¿åº¦ temp ä¸º1ï¼Œå¯¹ nums è¿›è¡Œç”Ÿåºæ’åºï¼Œéå†numsï¼Œå¦‚æœ `nums[i] == nums[i-1]+1` å°±è®© temp åŠ 1ï¼Œå¦åˆ™å½“`nums[i] != nums[i-1]` æ±‚`ans = max(ans, temp)` ï¼Œç„¶åé‡ç½®tempä¸º1ï¼Œé‡æ–°å¼€å§‹è®¡æ•°ã€‚åœ¨forå¾ªç¯å¤–ä¹Ÿéœ€è¦`ans = max(ans, temp)`ã€‚å¯»æ‰¾çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(N)$ï¼Œä½†æ˜¯å¿«æ’çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(NlogN)$ã€‚

```go
func longestConsecutive(nums []int) int {
	if len(nums) <= 1 {
		return len(nums)
	}
	ans := 1
	temp := 1
	sort.Slice(nums, func(i, j int) bool { return nums[i] < nums[j] })
	fmt.Println(nums)
	for i := 1; i < len(nums); i++ {
		//fmt.Println(nums[i])
		if nums[i] == nums[i-1]+1 {
			temp += 1
			//fmt.Println(temp)
		} else if nums[i] != nums[i-1] {
			ans = max(ans, temp)
			//fmt.Println(ans)
			temp = 1
		}
	}
	ans = max(ans, temp)
	return ans
}
```

2. é¦–å…ˆè½¬æ¢ä¸ºå“ˆå¸Œé›†åˆï¼Œ`set := map[int]bool{}`ï¼Œç„¶åéå†mapé›†åˆï¼Œåˆ¤æ–­set\[num - 1]æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨å°±è¯´æ˜ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡ã€‚æ‰¾åˆ°è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦ã€‚

```go
func longestConsecutive(nums []int) int {
    // è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
    set := make(map[int]bool)
    for _, num := range nums {
        set[num] = true
    }

    res := 0

    for num := range set {
        if set[num-1] {
            // num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
            continue
        }
        // num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
        curNum := num
        curLen := 1

        for set[curNum+1] {
            curNum += 1
            curLen += 1
        }
        // æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
        res = max(res, curLen)
    }

    return res
}
```

## 2. åŒæŒ‡é’ˆ

### Q283. ç§»åŠ¨é›¶

#### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªæ•°ç»„ `nums`ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ `0` ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚

**è¯·æ³¨æ„** ï¼Œå¿…é¡»åœ¨ä¸å¤åˆ¶æ•°ç»„çš„æƒ…å†µä¸‹åŸåœ°å¯¹æ•°ç»„è¿›è¡Œæ“ä½œã€‚&#x20;

**ç¤ºä¾‹ 1:**

<pre><code><strong>è¾“å…¥: nums = [0,1,0,3,12]
</strong><strong>è¾“å‡º: [1,3,12,0,0]
</strong></code></pre>

**ç¤ºä¾‹ 2:**

<pre><code><strong>è¾“å…¥: nums = [0]
</strong><strong>è¾“å‡º: [0]
</strong></code></pre>

**æç¤º**:

* `1 <= nums.length <= 104`
* `-231 <= nums[i] <= 231 - 1`

è¿›é˜¶ï¼šä½ èƒ½å°½é‡å‡å°‘å®Œæˆçš„æ“ä½œæ¬¡æ•°å—ï¼Ÿ

#### é¢˜è§£

ä½¿ç”¨åŒæŒ‡é’ˆï¼ŒæŒ‡é’ˆaå’ŒæŒ‡é’ˆbéƒ½ä½äºèµ·ç‚¹0ï¼Œç„¶åbå¾€å‰èµ°ï¼Œå¦‚æœé‡åˆ°ä¸æ˜¯0çš„ï¼Œå°±äº¤æ¢aï¼Œbçš„ä½ç½®ï¼ŒåŒæ—¶aå¾€å‰ç§»åŠ¨ä¸€ä½ã€‚\[\*\*\*a,00b]ï¼Œaå¯ä»¥ç†è§£ä¸ºåˆ†å¼€0ä¸é0å…ƒç´ çš„ç•Œé™ã€‚

```go
func moveZeroes(nums []int) {
	// å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œaï¼ŒbåŒæ—¶æŒ‡å‘0
	a := 0
	b := 0
	// bå¾€å‰èµ°ï¼Œå¦‚æœé‡åˆ°ä¸æ˜¯0çš„ï¼Œå°±äº¤æ¢aï¼Œbçš„ä½ç½®ï¼ŒåŒæ—¶aå¾€å‰ç§»åŠ¨ä¸€ä½
	// [***a,00b]ï¼Œaå¯ä»¥ç†è§£ä¸ºåˆ†å¼€0ä¸é0å…ƒç´ çš„ç•Œé™
	for ; b < len(nums); b++ {
		if nums[b] != 0 {
			nums[a], nums[b] = nums[b], nums[a]
			a += 1
		}
	}
}
```

### Q11. ç››æœ€å¤šæ°´çš„å®¹å™¨

#### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º `n` çš„æ•´æ•°æ•°ç»„ `height` ã€‚æœ‰ `n` æ¡å‚çº¿ï¼Œç¬¬ `i` æ¡çº¿çš„ä¸¤ä¸ªç«¯ç‚¹æ˜¯ `(i, 0)` å’Œ `(i, height[i])` ã€‚

æ‰¾å‡ºå…¶ä¸­çš„ä¸¤æ¡çº¿ï¼Œä½¿å¾—å®ƒä»¬ä¸ `x` è½´å…±åŒæ„æˆçš„å®¹å™¨å¯ä»¥å®¹çº³æœ€å¤šçš„æ°´ã€‚

è¿”å›å®¹å™¨å¯ä»¥å‚¨å­˜çš„æœ€å¤§æ°´é‡ã€‚

**è¯´æ˜ï¼š**ä½ ä¸èƒ½å€¾æ–œå®¹å™¨ã€‚

**ç¤ºä¾‹ 1ï¼š**

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question\_11.jpg)

<pre><code><strong>è¾“å…¥ï¼š[1,8,6,2,5,4,8,3,7]
</strong><strong>è¾“å‡ºï¼š49 
</strong><strong>è§£é‡Šï¼šå›¾ä¸­å‚ç›´çº¿ä»£è¡¨è¾“å…¥æ•°ç»„ [1,8,6,2,5,4,8,3,7]ã€‚åœ¨æ­¤æƒ…å†µä¸‹ï¼Œå®¹å™¨èƒ½å¤Ÿå®¹çº³æ°´ï¼ˆè¡¨ç¤ºä¸ºè“è‰²éƒ¨åˆ†ï¼‰çš„æœ€å¤§å€¼ä¸ºÂ 49ã€‚
</strong></code></pre>

**ç¤ºä¾‹ 2ï¼š**

<pre><code><strong>è¾“å…¥ï¼šheight = [1,1]
</strong><strong>è¾“å‡ºï¼š1
</strong></code></pre>

**æç¤ºï¼š**

* `n == height.length`
* `2 <= n <= 105`
* `0 <= height[i] <= 104`

#### é¢˜è§£

è¦æƒ³ç››æœ€å¤šçš„æ°´ï¼Œé‚£ä¹ˆå°±è¦å°½å¯èƒ½çš„ä¿è¯heightè¶³å¤Ÿé«˜ï¼Œå®½è¶³å¤Ÿå¤§ã€‚æ‰€ä»¥å¯ä»¥å…ˆä»ä¸¤è¾¹å¼€å§‹ï¼Œä½¿ç”¨åŒæŒ‡é’ˆæŒ‡å‘ä¸¤ç«¯ï¼Œç„¶åè®¡ç®—å½“å‰é¢ç§¯ï¼Œç„¶åå¦‚æœå·¦è¾¹heightæ¯”è¾ƒå°ï¼Œå°±ç§»åŠ¨å·¦è¾¹çš„ï¼Œå¦‚æœå³è¾¹æ¯”è¾ƒå°å°±ç§»åŠ¨å³è¾¹çš„ï¼Œç›´è‡³ç›¸é‡ã€‚

è¿™é‡Œé¢çš„é€»è¾‘å°±æ˜¯ç§»åŠ¨æœ€å°çš„ï¼Œä¿ç•™æ›´å¤§çš„æœ‰å¯èƒ½åœ¨åé¢ä¼šå¢å¤§é¢ç§¯ï¼Œè¿™æ˜¯ä¸€ç§è´ªå¿ƒæ€æƒ³ã€‚

```go
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0
    for left < right {
       currentArea := min(height[left], height[right]) * (right - left)
       maxArea = max(maxArea, currentArea)
       if height[left] < height[right] {
          left++
       } else {
          right--
       }
    }
    return maxArea
}

func max(a, b int) int {
    if a > b {
       return a
    } else {
       return b
    }
}

func min(a, b int) int {
    if a < b {
       return a
    } else {
       return b
    }
}
```

### Q15. ä¸‰å”ä¹‹å’Œ

#### é¢˜ç›®æè¿°ï¼š

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸‰å…ƒç»„ `[nums[i], nums[j], nums[k]]` æ»¡è¶³ `i != j`ã€`i != k` ä¸” `j != k` ï¼ŒåŒæ—¶è¿˜æ»¡è¶³ `nums[i] + nums[j] + nums[k] == 0` ã€‚è¯·

ä½ è¿”å›æ‰€æœ‰å’Œä¸º `0` ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚

**æ³¨æ„ï¼š**ç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„ã€‚

**ç¤ºä¾‹ 1ï¼š**

<pre><code><strong>è¾“å…¥ï¼šnums = [-1,0,1,2,-1,-4]
</strong><strong>è¾“å‡ºï¼š[[-1,-1,2],[-1,0,1]]
</strong><strong>è§£é‡Šï¼š
</strong>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 ã€‚
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 ã€‚
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 ã€‚
ä¸åŒçš„ä¸‰å…ƒç»„æ˜¯ [-1,0,1] å’Œ [-1,-1,2] ã€‚
æ³¨æ„ï¼Œè¾“å‡ºçš„é¡ºåºå’Œä¸‰å…ƒç»„çš„é¡ºåºå¹¶ä¸é‡è¦ã€‚
</code></pre>

**ç¤ºä¾‹ 2ï¼š**

<pre><code><strong>è¾“å…¥ï¼šnums = [0,1,1]
</strong><strong>è¾“å‡ºï¼š[]
</strong><strong>è§£é‡Šï¼šå”¯ä¸€å¯èƒ½çš„ä¸‰å…ƒç»„å’Œä¸ä¸º 0 ã€‚
</strong></code></pre>

**ç¤ºä¾‹ 3ï¼š**

<pre><code><strong>è¾“å…¥ï¼šnums = [0,0,0]
</strong><strong>è¾“å‡ºï¼š[[0,0,0]]
</strong><strong>è§£é‡Šï¼šå”¯ä¸€å¯èƒ½çš„ä¸‰å…ƒç»„å’Œä¸º 0 ã€‚
</strong></code></pre>

#### é¢˜è§£ï¼š

1. æš´åŠ›ï¼š

è¿™ä¸ªæ€è·¯æ²¡é—®é¢˜ï¼Œä½†æ˜¯ä¼šè¶…æ—¶ã€‚æ€æƒ³å°±æ˜¯å…ˆè¿›è¡Œæ’åºï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(nlogn)$ï¼Œç„¶åè¿›è¡Œå…¨éƒ¨çš„éå†ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯$O(N^3)$ã€‚

è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯æ’é™¤å¯èƒ½é‡å¤çš„ç»„åˆï¼Œå³å¦‚æœå½“å‰ä¸€ä¸ªå…ƒç´ å’Œä¸Šä¸€ä¸ªå…ƒç´ å€¼ä¸€æ ·ï¼Œè·³è¿‡ã€‚

```go
func threeSum(nums []int) [][]int {
	sort.Ints(nums)
	result := make([][]int, 0)
	for i := 0; i < len(nums)-2; i++ {
		if i > 0 && nums[i] == nums[i-1] {
			continue
		}
		for j := i + 1; j < len(nums)-1; j++ {
			if j > i+1 && nums[j] == nums[j-1] {
				continue
			}
			for k := j + 1; k < len(nums); k++ {
				if k > j+1 && nums[k] == nums[k-1] {
					continue
				}
				if nums[i]+nums[j]+nums[k] == 0 {
					result = append(result, []int{nums[i], nums[j], nums[k]})
				}
			}
		}
	}
	return result
}
```

2. åŒæŒ‡é’ˆ

åœ¨æœ€å¤–å±‚å¾ªç¯ä¸­ä¸ç¬¬ä¸€ç§è§£æ³•ä¿æŒä¸€è‡´ï¼Œç„¶åå¯¹äºåä¸¤ä¸ªæ•°çš„é€‰æ‹©ï¼Œä½¿ç”¨å·¦å³æŒ‡é’ˆæŒ‡å‘ä¸¤è¾¹ï¼Œä¸æ–­å‘ä¸­é—´é æ‹¢ã€‚

å¦‚æœæ‰¾åˆ°äº†ï¼Œå°±ç¼©å°èŒƒå›´ï¼Œleft++ï¼Œright--ï¼ŒåŒæ—¶å‡å°‘å¯èƒ½å­˜åœ¨çš„é‡å¤ç»„åˆã€‚

å¦‚æœsum < 0ï¼Œ left++

å¦‚æœsum > 0ï¼Œright--

æ‰€ä»¥æ•´ä½“æ—¶é—´å¤æ‚åº¦ä¸º$O(N^2)$&#x20;

```go
func threeSum(nums []int) [][]int {
	sort.Ints(nums)
	result := make([][]int, 0)
	for i := 0; i < len(nums)-2; i++ {
		if i > 0 && nums[i] == nums[i-1] {
			continue
		}
		left, right := i+1, len(nums)-1
		for left < right {
			sum := nums[i] + nums[left] + nums[right]
			if sum == 0 {
				result = append(result, []int{nums[i], nums[left], nums[right]})
				left++
				right--
				for left < right && nums[left] == nums[left-1] {
					left++
				}
				for left < right && nums[right] == nums[right+1] {
					right--
				}
			} else if sum < 0 {
				left++
			} else {
				right--
			}
		}
	}
	return result
}
```
